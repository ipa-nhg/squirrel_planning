#ifndef KCL_ROSPLAN_PLANTOASKPDDLGENERATOR_H
#define KCL_ROSPLAN_PLANTOASKPDDLGENERATOR_H

#include "squirrel_planning_execution/RecommenderSystem.h"

/**
 * Creates a PDDL domain and problem file that models the plan to sense domain. It gets its information 
 * from the recommender system that suggests a sequence of observation actions to perform. Before such 
 * action can be performed, we need to find these objects.
 */
namespace KCL_rosplan {
	
	class PlanToAskPDDLGenerator
	{
	private:
		
		/**
		* Data structure of a location, for each location we store the name, whether it is clear and all the 
		* locations it is connected to.
		*/
		struct Location
		{
			Location(const std::string& name, bool is_blocked)
				: name_(name), is_blocked_(is_blocked)
			{
				
			}
			
			Location(const std::string& name, bool is_blocked, const std::vector<const Location*>& connected_locations)
				: name_(name), is_blocked_(is_blocked), connected_locations_(connected_locations)
			{
				
			}
			
			std::string name_;
			bool is_blocked_;
			std::vector<const Location*> connected_locations_;
			std::vector<const Location*> near_locations_;
		};

		/**
		* Data structure of an object, for each object we store the name, the location at which it is stored, and all 
		* locations from where it is classifiable.
		*/
		struct Toy
		{
			Toy(const std::string& name, const Location& location)
				: name_(name), location_(&location)
			{
				
			}
			
			std::string name_;
			const Location* location_;
		};
		
		struct Box
		{
			Box(const std::string& name, const Location& location, const std::vector<const Toy*>& objects_inside)
				: name_(name), location_(&location)
			{
				
			}
			
			std::string name_;
			const Location* location_;
			std::vector<const Toy*> objects_inside_;
		};
		
		struct TreeNode;
		
		/**
		 * Data structure of a believe state. Each state has a name and it contains for a subset of objects the location from 
		 * where it will be classified. The subset of objects depends on the factorisation that is performed in the knowledge base.
		 * In this specific instance each object is part of a seperate Knowledge base which means that each state contains only ONE 
		 * mapping from one object to one location.
		 */
		struct State
		{
			State(const std::string& state_name, const std::vector<const TreeNode*>& sense_sequence, const std::map<const Toy*, const Box*>& believe_state)
				: state_name_(state_name), sense_sequence_(sense_sequence), believe_state_(believe_state)
			{
				
			}
			
			std::string state_name_;                             // The unique name of this state.
			std::vector<const TreeNode*> sense_sequence_;        // The sequence of observations that need to be made.
			std::map<const Toy*, const Box*> believe_state_;     // The believe state.
		};
		
		struct TreeNode
		{
			TreeNode(const Box& box, const Toy& object, TreeNode* parent, bool is_true_branch)
				: box_(&box), object_(&object), parent_(parent), false_branch_(NULL), true_branch_(NULL), is_true_branch_(is_true_branch)
			{
				
			}
			
			/**
			 * Create a tree node given a node of the FactObserveTree (generated by the recommender). In addition we generate 
			 * all believe states that are needed by the planner.
			 */
			TreeNode(TreeNode* parent, bool is_true_branch, const FactObserveTree& fact_tree, std::map<std::string, const Toy*>& toy_mapping, std::map<std::string, const Box*>& box_mapping, std::vector<State*>& generated_states)
				: parent_(parent), false_branch_(NULL), true_branch_(NULL), is_true_branch_(is_true_branch)
			{
				object_ = toy_mapping[fact_tree.fact_to_observe_->getObjects()[0]->getName()];
				box_ = box_mapping[fact_tree.fact_to_observe_->getObjects()[1]->getName()];
				
				std::cout << "Create a TreeNode. Object= " << object_->name_ << ". Box= " << box_->name_ << std::endl;
				std::cout << "\tTRUE: ";
				if (fact_tree.true_branch_ != NULL)
				{
					std::cout << *fact_tree.true_branch_->fact_to_observe_;
				}
				std::cout << std::endl;
				std::cout << "\tFALSE: ";
				if (fact_tree.false_branch_ != NULL)
				{
					std::cout << *fact_tree.false_branch_->fact_to_observe_;
				}
				std::cout << std::endl;
				
				if (fact_tree.true_branch_ != NULL)
				{
					true_branch_ = new TreeNode(this, true, *fact_tree.true_branch_, toy_mapping, box_mapping, generated_states);
				}
				else
				{
					TreeNode* true_leaf = new TreeNode(*box_, *object_, this, true);
					generated_states.push_back(true_leaf->createState(generated_states.size(), box_mapping));
				}
				
				if (fact_tree.false_branch_ != NULL)
				{
					false_branch_ = new TreeNode(this, false, *fact_tree.false_branch_, toy_mapping, box_mapping, generated_states);
				}
				else
				{
					TreeNode* false_leaf = new TreeNode(*box_, *object_, this, false);
					generated_states.push_back(false_leaf->createState(generated_states.size(), box_mapping));
				}
			}
			
			/**
			 * Create a believe state, we treat this node as a dead end.
			 */
			State* createState(unsigned int state_nr, std::map<std::string, const Box*>& box_mapping)
			{
				TreeNode* current_node = this;
				std::vector<const TreeNode*> sense_sequence;
				std::map<const Toy*, const Box*> believe_state;
				while (true) 
				{
					if (current_node != this)
					{
						sense_sequence.insert(sense_sequence.begin(), current_node);
					}
					
					if (current_node->parent_ == NULL) break;
					
					if (current_node->is_true_branch_)
						believe_state[current_node->parent_->object_] = current_node->parent_->box_;
					else
					{
						const Box* other_box;
						for (std::map<std::string, const Box*>::const_iterator ci = box_mapping.begin(); ci != box_mapping.end(); ++ci)
						{
							if (ci->second != current_node->parent_->box_)
							{
								other_box = ci->second;
								break;
							}
						}
						believe_state[current_node->parent_->object_] = other_box;
					}
					current_node = current_node->parent_;
				}
				
				std::stringstream ss;
				ss << "state" << state_nr;
				
				State* state = new State(ss.str(), sense_sequence, believe_state);
				
				std::cout << "Created a new state: " << state->state_name_ << std::endl;
				std::cout << "\tSequence: [" ;
				for (std::vector<const TreeNode*>::const_iterator ci = state->sense_sequence_.begin(); ci != state->sense_sequence_.end(); ++ci)
				{
					std::cout << "(" << (*ci)->object_->name_ << " " << (*ci)->box_->name_ << "), ";
				}
				std::cout << "]" << std::endl;
				
				for (std::map<const Toy*, const Box*>::const_iterator ci = state->believe_state_.begin(); ci != state->believe_state_.end(); ++ci)
				{
					std::cout << "\tB: " << ci->first->name_ << " -> " << ci->second->name_ << std::endl;
				}
				
			
				return state;
			}
			
			const Box* box_;       // The box to put the object in.
			const Toy* object_; // The object to put in a box.
			
			TreeNode* parent_;       // Parent node.
			TreeNode* false_branch_; // The false branch.
			TreeNode* true_branch_;  // The true branch.
			bool is_true_branch_;    // Whether this is the true or false branch.
		};
		
		/**
		 * Data structure for a knowledge base. The knowledge bases are created based on the factorisation of the domain. In this 
		 * specific instance each object is part of a seperate Knowledge base. So the number of knowledge bases is #objects + 1, the +1 
		 * is the global knowledge base. Each knowledge base contains a set of states which are the believe states, each state encodes 
		 * from which observation point an object is classifiable.
		 */
		struct KnowledgeBase
		{
			KnowledgeBase(const std::string& name)
				: name_(name)
			{
				
			}
			
			void addChild(const KnowledgeBase& knowledge_base)
			{
				children_.push_back(&knowledge_base);
			}
			
			void addState(State& state)
			{
				states_.push_back(&state);
			}
			
			std::string name_;
			std::vector<const State*> states_;
			std::vector<const KnowledgeBase*> children_;
		};
		
		/**
		 * Generate the problem file given the set of objects, locations, etc.
		 * @param file_name The path and file name of where the problem file should be written to.
		 * @param current_knowledge_base The global knowledge base that is active in the initial state.
		 * @param knowledge_bases All the knowledge bases the planning problem is factorised in.
		 * @param robot_location The initial location of the robot.
		 * @param locations All the locations that exist in the domain.
		 * @param objects All the objects that exist in the domain that must be classified.
		 * @param boxes All the boxes that exist in the domain.
		 * @param types All the types that exist in the domain.
		 */
		static void generateProblemFile(const std::string& file_name, const KnowledgeBase& current_knowledge_base, const std::vector<const KnowledgeBase*>& knowledge_bases, const Location& robot_location, const std::vector<Location*>& locations, const std::vector<Toy*>& objects, const std::vector<const Box*>& boxes, const TreeNode& root);
		
		/**
		 * Generate the domain file given the set of objects, locations, etc.
		 * @param file_name The path and file name of where the domain file should be written to.
		 * @param current_knowledge_base The global knowledge base that is active in the initial state.
		 * @param knowledge_bases All the knowledge bases the planning problem is factorised in.
		 * @param robot_location The initial location of the robot.
		 * @param locations All the locations that exist in the domain.
		 * @param objects All the objects that exist in the domain that must be classified.
		 * @param boxes All the boxes that exist in the domain.
		 * @param types All the types that exist in the domain.
		 */
		static void generateDomainFile(const std::string& file_name, const KnowledgeBase& current_knowledge_base, const std::vector<const KnowledgeBase*>& knowledge_bases, const Location& robot_location, const std::vector<Location*>& locations, const std::vector<Toy*>& objects, const std::vector<const Box*>& boxes, const TreeNode& root);

	public:
		
		/**
		 * Create the PDDL domain and problem file, the name of the domain file is @ref{path}/@ref{domain_file} and the 
		 * name of the problem file is @ref{path}/@ref{problem_path}.
		 * @param root Root of the tree of facts that need to be observed.
		 * @param path The path where the domain and problem files are stored.
		 * @param domain_file The name of the PDDL file where the domain is stored.
		 * @param problem_file The name of the PDDL file where the problem is stored.
		 * @param robot_location_predicate The predicate name of the waypoint where the robot is.
		 * @param object_to_location_mapping A mapping for each object predicate to the location predicate where it is located.
		 * @param object_to_type_mapping A mapping for each object predicate to the type predicate 
		 * @param box_to_location_mapping A mapping for each box to its location predicate.
		 * @param box_to_type_mapping A mapping for each box to the type predicate of each object type it can contain.
		 * @param near_box_location_mapping A mapping from box location to location near it.
		 */
		static void createPDDL(FactObserveTree& root, const std::string& path, const std::string& domain_file, const std::string& problem_file, const std::string& robot_location_predicate, const std::map<std::string, std::string>& object_to_location_mapping, const std::map<std::string, std::string>& box_to_location_mapping);
	};
}
#endif
